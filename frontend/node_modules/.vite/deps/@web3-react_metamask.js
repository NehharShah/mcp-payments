import {
  __commonJS
} from "./chunk-4B2QHNJT.js";

// node_modules/@web3-react/types/dist/index.js
var require_dist = __commonJS({
  "node_modules/@web3-react/types/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Connector = void 0;
    var Connector = class {
      /**
       * @param actions - Methods bound to a zustand store that tracks the state of the connector.
       * @param onError - An optional handler which will report errors thrown from event listeners.
       * Actions are used by the connector to report changes in connection status.
       */
      constructor(actions, onError) {
        this.actions = actions;
        this.onError = onError;
      }
      /**
       * Reset the state of the connector without otherwise interacting with the connection.
       */
      resetState() {
        this.actions.resetState();
      }
    };
    exports.Connector = Connector;
  }
});

// node_modules/@metamask/detect-provider/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/@metamask/detect-provider/dist/index.js"(exports, module) {
    "use strict";
    function detectEthereumProvider({ mustBeMetaMask = false, silent = false, timeout = 3e3 } = {}) {
      _validateInputs();
      let handled = false;
      return new Promise((resolve) => {
        if (window.ethereum) {
          handleEthereum();
        } else {
          window.addEventListener("ethereum#initialized", handleEthereum, { once: true });
          setTimeout(() => {
            handleEthereum();
          }, timeout);
        }
        function handleEthereum() {
          if (handled) {
            return;
          }
          handled = true;
          window.removeEventListener("ethereum#initialized", handleEthereum);
          const { ethereum } = window;
          if (ethereum && (!mustBeMetaMask || ethereum.isMetaMask)) {
            resolve(ethereum);
          } else {
            const message = mustBeMetaMask && ethereum ? "Non-MetaMask window.ethereum detected." : "Unable to detect window.ethereum.";
            !silent && console.error("@metamask/detect-provider:", message);
            resolve(null);
          }
        }
      });
      function _validateInputs() {
        if (typeof mustBeMetaMask !== "boolean") {
          throw new Error(`@metamask/detect-provider: Expected option 'mustBeMetaMask' to be a boolean.`);
        }
        if (typeof silent !== "boolean") {
          throw new Error(`@metamask/detect-provider: Expected option 'silent' to be a boolean.`);
        }
        if (typeof timeout !== "number") {
          throw new Error(`@metamask/detect-provider: Expected option 'timeout' to be a number.`);
        }
      }
    }
    module.exports = detectEthereumProvider;
  }
});

// node_modules/@web3-react/metamask/dist/index.js
var require_dist3 = __commonJS({
  "node_modules/@web3-react/metamask/dist/index.js"(exports) {
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MetaMask = exports.NoMetaMaskError = void 0;
    var types_1 = require_dist();
    var NoMetaMaskError = class _NoMetaMaskError extends Error {
      constructor() {
        super("MetaMask not installed");
        this.name = _NoMetaMaskError.name;
        Object.setPrototypeOf(this, _NoMetaMaskError.prototype);
      }
    };
    exports.NoMetaMaskError = NoMetaMaskError;
    function parseChainId(chainId) {
      return Number.parseInt(chainId, 16);
    }
    var MetaMask = class extends types_1.Connector {
      constructor({ actions, options, onError }) {
        super(actions, onError);
        this.options = options;
      }
      isomorphicInitialize() {
        return __awaiter(this, void 0, void 0, function* () {
          if (this.eagerConnection)
            return;
          return this.eagerConnection = Promise.resolve().then(() => __importStar(require_dist2())).then((m) => __awaiter(this, void 0, void 0, function* () {
            var _a, _b;
            const provider = yield m.default(this.options);
            if (provider) {
              this.provider = provider;
              if ((_a = this.provider.providers) === null || _a === void 0 ? void 0 : _a.length) {
                this.provider = (_b = this.provider.providers.find((p) => p.isMetaMask)) !== null && _b !== void 0 ? _b : this.provider.providers[0];
              }
              this.provider.on("connect", ({ chainId }) => {
                this.actions.update({ chainId: parseChainId(chainId) });
              });
              this.provider.on("disconnect", (error) => {
                var _a2;
                if (error.code === 1013) {
                  console.debug('MetaMask logged connection error 1013: "Try again later"');
                  return;
                }
                this.actions.resetState();
                (_a2 = this.onError) === null || _a2 === void 0 ? void 0 : _a2.call(this, error);
              });
              this.provider.on("chainChanged", (chainId) => {
                this.actions.update({ chainId: parseChainId(chainId) });
              });
              this.provider.on("accountsChanged", (accounts) => {
                if (accounts.length === 0) {
                  this.actions.resetState();
                } else {
                  this.actions.update({ accounts });
                }
              });
            }
          }));
        });
      }
      /** {@inheritdoc Connector.connectEagerly} */
      connectEagerly() {
        return __awaiter(this, void 0, void 0, function* () {
          const cancelActivation = this.actions.startActivation();
          try {
            yield this.isomorphicInitialize();
            if (!this.provider)
              return cancelActivation();
            const accounts = yield this.provider.request({ method: "eth_accounts" });
            if (!accounts.length)
              throw new Error("No accounts returned");
            const chainId = yield this.provider.request({ method: "eth_chainId" });
            this.actions.update({ chainId: parseChainId(chainId), accounts });
          } catch (error) {
            console.debug("Could not connect eagerly", error);
            this.actions.resetState();
          }
        });
      }
      /**
       * Initiates a connection.
       *
       * @param desiredChainIdOrChainParameters - If defined, indicates the desired chain to connect to. If the user is
       * already connected to this chain, no additional steps will be taken. Otherwise, the user will be prompted to switch
       * to the chain, if one of two conditions is met: either they already have it added in their extension, or the
       * argument is of type AddEthereumChainParameter, in which case the user will be prompted to add the chain with the
       * specified parameters first, before being prompted to switch.
       */
      activate(desiredChainIdOrChainParameters) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
          let cancelActivation;
          if (!((_b = (_a = this.provider) === null || _a === void 0 ? void 0 : _a.isConnected) === null || _b === void 0 ? void 0 : _b.call(_a)))
            cancelActivation = this.actions.startActivation();
          return this.isomorphicInitialize().then(() => __awaiter(this, void 0, void 0, function* () {
            if (!this.provider)
              throw new NoMetaMaskError();
            const accounts = yield this.provider.request({ method: "eth_requestAccounts" });
            const chainId = yield this.provider.request({ method: "eth_chainId" });
            const receivedChainId = parseChainId(chainId);
            const desiredChainId = typeof desiredChainIdOrChainParameters === "number" ? desiredChainIdOrChainParameters : desiredChainIdOrChainParameters === null || desiredChainIdOrChainParameters === void 0 ? void 0 : desiredChainIdOrChainParameters.chainId;
            if (!desiredChainId || receivedChainId === desiredChainId)
              return this.actions.update({ chainId: receivedChainId, accounts });
            const desiredChainIdHex = `0x${desiredChainId.toString(16)}`;
            return this.provider.request({
              method: "wallet_switchEthereumChain",
              params: [{ chainId: desiredChainIdHex }]
            }).catch((error) => {
              var _a2, _b2;
              const errorCode = ((_b2 = (_a2 = error.data) === null || _a2 === void 0 ? void 0 : _a2.originalError) === null || _b2 === void 0 ? void 0 : _b2.code) || error.code;
              if (errorCode === 4902 && typeof desiredChainIdOrChainParameters !== "number") {
                if (!this.provider)
                  throw new Error("No provider");
                return this.provider.request({
                  method: "wallet_addEthereumChain",
                  params: [Object.assign(Object.assign({}, desiredChainIdOrChainParameters), { chainId: desiredChainIdHex })]
                });
              }
              throw error;
            }).then(() => this.activate(desiredChainId));
          })).catch((error) => {
            cancelActivation === null || cancelActivation === void 0 ? void 0 : cancelActivation();
            throw error;
          });
        });
      }
      watchAsset({ address, symbol, decimals, image }) {
        return __awaiter(this, void 0, void 0, function* () {
          if (!this.provider)
            throw new Error("No provider");
          return this.provider.request({
            method: "wallet_watchAsset",
            params: {
              type: "ERC20",
              options: {
                address,
                symbol,
                decimals,
                image
                // A string url of the token logo
              }
            }
          }).then((success) => {
            if (!success)
              throw new Error("Rejected");
            return true;
          });
        });
      }
    };
    exports.MetaMask = MetaMask;
  }
});
export default require_dist3();
//# sourceMappingURL=@web3-react_metamask.js.map
